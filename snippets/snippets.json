{
    "addon_info": {
        "prefix": "info addon",
        "body": [
            "bl_info = {",
            "\t\"name\": \"${1:My Addon Name}\",",
            "\t\"description\": \"${2:Description of this addon}\",",
            "\t\"author\": \"${3:Authors name}\",",
            "\t\"version\": (${4:0, 0, 1}),",
            "\t\"blender\": (${5:2, 9, 0}),",
            "\t\"location\": \"${6:View3D}\",",
            "\t\"warning\": \"This addon is still in development.\",",
            "\t\"wiki_url\": \"\",",
            "\t\"category\": \"${7:Object}\" }",
            "\t"
        ],
        "description": "Blender addon info"
    },
    "GNU_license": {
        "prefix": "license gnu",
        "body": [
            "'''",
            "Copyright (C) ${1:2018} ${2:ADDONCREATORNAME}",
            "${3:ADDONCREATORNAME@MAIL.COM}",
            "",
            "Created by ${2:ADDONCREATORNAME}",
            "",
            "\tThis program is free software: you can redistribute it and/or modify",
            "\tit under the terms of the GNU General Public License as published by",
            "\tthe Free Software Foundation, either version 3 of the License, or",
            "\t(at your option) any later version.",
            "",
            "\tThis program is distributed in the hope that it will be useful,",
            "\tbut WITHOUT ANY WARRANTY; without even the implied warranty of",
            "\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "\tGNU General Public License for more details.",
            "",
            "\tYou should have received a copy of the GNU General Public License",
            "\talong with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "'''"
        ],
        "description": "GNU license"
    },
    "license_MIT": {
        "prefix": "license mit",
        "body": [
            "MIT License",
            "",
            "Copyright (c) ${1:2018} ${2:AUTHORSNAME}",
            "",
            "Permission is hereby granted, free of charge, to any person obtaining a copy",
            "of this software and associated documentation files (the \"Software\"), to deal",
            "in the Software without restriction, including without limitation the rights",
            "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
            "copies of the Software, and to permit persons to whom the Software is",
            "furnished to do so, subject to the following conditions:",
            "",
            "The above copyright notice and this permission notice shall be included in all",
            "copies or substantial portions of the Software.",
            "",
            "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
            "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
            "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
            "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
            "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
            "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE",
            "SOFTWARE."
        ],
        "description": "MIT license"
    },
    "keymap_item": {
        "prefix": "keymap item",
        "body": [
            "kmi = km.keymap_items.new(",
            "\tname=\"${1:keymapname}\",",
            "\tidname=\"${2:Operator.bl_idname}\",",
            "\ttype=\"${3:KEYMAP}\",",
            "\tvalue=\"${4:PRESS}\",",
            "\tshift=${5:False},",
            "\tctrl=${6:False},",
            "\talt = ${7:False},",
            "\toskey=${8:False}",
            "\t$0)"
        ],
        "description": "keymap item [more info](https://docs.blender.org/api/current/bpy.types.KeyMapItem.html#bpy.types.KeyMapItem)"
    },    
    "keymap": {
        "prefix": "keymaps",
        "body": [
            "addon_keymaps = []",
            "def register_keymaps():",
            "\taddon = bpy.context.window_manager.keyconfigs.addon",
            "\tkm = addon.keymaps.new(name = \"3D View\", space_type = \"VIEW_3D\")",
            "\t# insert keymap items here",
            "\taddon_keymaps.append(km)",
            "",
            "def unregister_keymaps():",
            "\twm = bpy.context.window_manager",
            "\tfor km in addon_keymaps:",
            "\t\tfor kmi in km.keymap_items:",
            "\t\t\tkm.keymap_items.remove(kmi)",
            "\t\twm.keyconfigs.addon.keymaps.remove(km)",
            "\taddon_keymaps.clear()"
        ],
        "description": "Register and unregister keymaps"
    },
    "menu": {
        "prefix": "menu",
        "body": [
            "class ${1:MenuClassName}(bpy.types.Menu):",
            "\tbl_idname = \"${2:view3d.menuname}\"",
            "\tbl_label = \"${3:Menu name}\"",
            "",
            "\tdef draw(self, context):",
            "\t\tlayout = self.layout",
            "\t\t$0"
        ],
        "description": "Menu"
    },

    "operator_simple":{
        "prefix": "operator",
        "body": [
            "class ${1:MyClassName}(bpy.types.Operator):",
            "\tbl_idname = \"${2:my_operator.my_class_name}\"",
            "\tbl_label = \"${3:My Class Name}\"",
            "\tbl_description = \"${4:Description that shows in blender tooltips}\"",
            "\tbl_options = {\"REGISTER\"}",
            "",
            "\t@classmethod",
            "\tdef poll(cls, context):",
            "\t\treturn True",
            "",
            "\tdef execute(self, context):",
            "\t\t$0",
            "\t\treturn {\"FINISHED\"}",
            ""
        ],
        "description": "Operator function class, without any imports or added functions"
    },
    "modal_operator":{
        "prefix": "operator modal",
        "body": [
            "class ${1:MyClassName}(bpy.types.Operator):",
            "\tbl_idname = \"${2:my_operator.my_class_name}\"",
            "\tbl_label = \"${3:My Class Name}\"",
            "\tbl_description = \"${4:Description that shows in blender tooltips}\"",
            "\tbl_options = {'REGISTER'}",
            "",
            "\t@classmethod",
            "\tdef poll(cls, context):",
            "\t\treturn True",
            "",
            "\tdef invoke(self, context, event):",
            "\t\tcontext.window_manager.modal_handler_add(self)",
            "\t\treturn {\"RUNNING_MODAL\"}",
            "",
            "\tdef modal(self, context, event):",
            "\t\t",
            "\t\tif event.type == \"LEFTMOUSE\":",
            "\t\t\treturn {\"FINISHED\"}",
            "\t\t",
            "\t\tif event.type in {\"RIGHTMOUSE\", \"ESC\"}:",
            "\t\t\treturn {\"CANCELLED\"}",
            "\t\t$0",
            "\t\treturn {\"RUNNING_MODAL\"}",
            ""
        ],
        "description": "Modal operator function, without any imports or added functions"
    },
    "modal_operator_draw":{
            "prefix": "operator modal draw",
            "body": [
                "class ${1:MyClassName}(bpy.types.Operator):",
                "\tbl_idname = \"${2:my_operator.my_class_name}\"",
                "\tbl_label = \"${3:My Class Name}\"",
                "\tbl_description = \"${4:Description that shows in blender tooltips}\"",
                "\tbl_options = {'REGISTER'}",
                "",
                "\t@classmethod",
                "\tdef poll(cls, context):",
                "\t\treturn True",
                "",
                "\tdef invoke(self, context, event):",
                "\t\tself._handle = bpy.types.SpaceView3D.draw_handler_add(",
                "\t\t\tself.draw_callback_px, args, \"WINDOW\", \"POST_PIXEL\")",
                "\t\tcontext.window_manager.modal_handler_add(self)",
                "\t\treturn {\"RUNNING_MODAL\"}",
                "",
                "\tdef modal(self, context, event):",
                "\t\t",
                "\t\tif event.type == \"LEFTMOUSE\":",
                "\t\t\treturn self.finish()",
                "\t\t",
                "\t\tif event.type in {\"RIGHTMOUSE\", \"ESC\"}:",
                "\t\t\treturn self.cancelled()",
                "\t\t$0",
                "\t\treturn {\"RUNNING_MODAL\"}",
                "",
                "\tdef finish(self):",
                "\t\tbpy.types.SpaceView3D.draw_handler_remove(self._handle, \"WINDOW\")",
                "\t\treturn {\"FINISHED\"}",
                "",
                "\tdef cancelled(self):",
                "\t\tbpy.types.SpaceView3D.draw_handler_remove(self._handle, \"WINDOW\")",
                "\t\treturn {\"CANCELLED\"}",
                "",
                "\tdef draw_callback_px(tmp, self, context):",
                "\t\tpass",
                ""
            ],
            "description": "Modal operator draw function, without any imports or added functions"
    },
    "panel": {
        "prefix": "panel",
        "body": [
            "class ${1:PanelClassName}(bpy.types.Panel):",
            "\tbl_idname = \"${2:panelname}\"",
            "\tbl_label = \"${3:Panelname}\"",
            "\tbl_space_type = \"${4:VIEW_3D}\"",
            "\tbl_region_type = \"${5:TOOLS}\"",
            "\tbl_category = \"${6:category}\"",
            "",
            "\tdef draw(self, context):",
            "\t\tlayout = self.layout",
            "\t\t$0"
        ],
        "description": "Panel"
    },
    "pie_menu": {
        "prefix": "pie menu",
        "body": [
            "class ${1:ClassMenuName}(bpy.types.Menu):",
            "\tbl_idname = \"${2:view3d.menuname}\"",
            "\tbl_label = \"${3:Menuname}\"",
            "",
            "\tdef draw(self, context):",
            "\t\tpie = self.layout.menu_pie()",
            "\t\t$0"
        ],
        "description": "Pie Menu"
    },
    "register_functions": {
        "prefix": "register",
        "body": [
            "def register():",
            "\tbpy.utils.register_module(__name__)",
            "",
            "def unregister():",
            "\tbpy.utils.unregister_module(__name__)",
            "",
            "if __name__ == \"__main__\":",
            "\tregister()"
        ],
        "description": "Register and Unregister Module"
    },
    "template_addon_add_object":{
        "prefix": "template addon",
        "body": [
            "bl_info = {",
            "\t\"name\": \"New Object\",",
            "\t\"author\": \"Your Name Here\",",
            "\t\"version\": (1, 0),",
            "\t\"blender\": (2, 75, 0),",
            "\t\"location\": \"View3D > Add > Mesh > New Object\",",
            "\t\"description\": \"Adds a new Mesh Object\",",
            "\t\"warning\": \"\",",
            "\t\"wiki_url\": \"\",",
            "\t\"category\": \"Add Mesh\",",
            "\t}",
            "",
            "",
            "import bpy",
            "from bpy.types import Operator",
            "from bpy.props import FloatVectorProperty",
            "from bpy_extras.object_utils import AddObjectHelper, object_data_add",
            "from mathutils import Vector",
            "",
            "",
            "def add_object(self, context):",
            "\tscale_x = self.scale.x",
            "\tscale_y = self.scale.y",
            "",
            "\tverts = [Vector((-1 * scale_x, 1 * scale_y, 0)),",
            "\t         Vector((1 * scale_x, 1 * scale_y, 0)),",
            "\t         Vector((1 * scale_x, -1 * scale_y, 0)),",
            "\t         Vector((-1 * scale_x, -1 * scale_y, 0)),",
            "\t         ]",
            "",
            "\tedges = []",
            "\tfaces = [[0, 1, 2, 3]]",
            "",
            "\tmesh = bpy.data.meshes.new(name=\"New Object Mesh\")",
            "\tmesh.from_pydata(verts, edges, faces)",
            "\t# useful for development when the mesh may be invalid.",
            "\t# mesh.validate(verbose=True)",
            "\tobject_data_add(context, mesh, operator=self)",
            "",
            "",
            "class OBJECT_OT_add_object(Operator, AddObjectHelper):",
            "\t\"\"\"Create a new Mesh Object\"\"\"",
            "\tbl_idname = \"mesh.add_object\"",
            "\tbl_label = \"Add Mesh Object\"",
            "\tbl_options = {'REGISTER', 'UNDO'}",
            "",
            "\tscale = FloatVectorProperty(",
            "\t\t\tname=\"scale\",",
            "\t\t\tdefault=(1.0, 1.0, 1.0),",
            "\t\t\tsubtype='TRANSLATION',",
            "\t\t\tdescription=\"scaling\",",
            "\t\t\t)",
            "",
            "\tdef execute(self, context):",
            "",
            "\t\tadd_object(self, context)",
            "",
            "\t\treturn {'FINISHED'}",
            "",
            "",
            "# Registration",
            "",
            "def add_object_button(self, context):",
            "\tself.layout.operator(",
            "\t\tOBJECT_OT_add_object.bl_idname,",
            "\t\ttext=\"Add Object\",",
            "\t\ticon='PLUGIN')",
            "",
            "",
            "# This allows you to right click on a button and link to the manual",
            "def add_object_manual_map():",
            "\turl_manual_prefix = \"https://docs.blender.org/manual/en/dev/\"",
            "\turl_manual_mapping = (",
            "\t\t(\"bpy.ops.mesh.add_object\", \"editors/3dview/object\"),",
            "\t\t)",
            "\treturn url_manual_prefix, url_manual_mapping",
            "",
            "",
            "def register():",
            "\tbpy.utils.register_class(OBJECT_OT_add_object)",
            "\tbpy.utils.register_manual_map(add_object_manual_map)",
            "\tbpy.types.INFO_MT_mesh_add.append(add_object_button)",
            "",
            "",
            "def unregister():",
            "\tbpy.utils.unregister_class(OBJECT_OT_add_object)",
            "\tbpy.utils.unregister_manual_map(add_object_manual_map)",
            "\tbpy.types.INFO_MT_mesh_add.remove(add_object_button)",
            "",
            "",
            "if __name__ == \"__main__\":",
            "\tregister()"
        ],
        "description": "Example of addon for adding object"
    },
    "template_background_job":{
        "prefix": "template background job",
        "body": [
            "# This script is an example of how you can run blender from the command line",
            "# (in background mode with no interface) to automate tasks, in this example it",
            "# creates a text object, camera and light, then renders and/or saves it.",
            "# This example also shows how you can parse command line options to scripts.",
            "#",
            "# Example usage for this test.",
            "#  blender --background --factory-startup --python \\$HOME/background_job.py -- \\",
            "#          --text=\"Hello World\" \\",
            "#          --render=\"/tmp/hello\" \\",
            "#          --save=\"/tmp/hello.blend\"",
            "#",
            "# Notice:",
            "# '--factory-startup' is used to avoid the user default settings from",
            "#                     interfering with automated scene generation.",
            "#",
            "# '--' causes blender to ignore all following arguments so python can use them.",
            "#",
            "# See blender --help for details.",
            "",
            "import bpy",
            "",
            "",
            "def example_function(text, save_path, render_path):",
            "",
            "\tscene = bpy.context.scene",
            "",
            "\t# Clear existing objects.",
            "\tscene.camera = None",
            "\tfor obj in scene.objects:",
            "\t\tscene.objects.unlink(obj)",
            "",
            "\ttxt_data = bpy.data.curves.new(name=\"MyText\", type='FONT')",
            "",
            "\t# Text Object",
            "\ttxt_ob = bpy.data.objects.new(name=\"MyText\", object_data=txt_data)",
            "\tscene.objects.link(txt_ob)  # add the data to the scene as an object",
            "\ttxt_data.body = text        # the body text to the command line arg given",
            "\ttxt_data.align = 'CENTER'   # center text",
            "",
            "\t# Camera",
            "\tcam_data = bpy.data.cameras.new(\"MyCam\")",
            "\tcam_ob = bpy.data.objects.new(name=\"MyCam\", object_data=cam_data)",
            "\tscene.objects.link(cam_ob)  # instance the camera object in the scene",
            "\tscene.camera = cam_ob       # set the active camera",
            "\tcam_ob.location = 0.0, 0.0, 10.0",
            "",
            "\t# Lamp",
            "\tlamp_data = bpy.data.lamps.new(\"MyLamp\", 'POINT')",
            "\tlamp_ob = bpy.data.objects.new(name=\"MyCam\", object_data=lamp_data)",
            "\tscene.objects.link(lamp_ob)",
            "\tlamp_ob.location = 2.0, 2.0, 5.0",
            "",
            "\tif save_path:",
            "\t\tbpy.ops.wm.save_as_mainfile(filepath=save_path)",
            "",
            "\tif render_path:",
            "\t\trender = scene.render",
            "\t\trender.use_file_extension = True",
            "\t\trender.filepath = render_path",
            "\t\tbpy.ops.render.render(write_still=True)",
            "",
            "",
            "def main():",
            "\timport sys       # to get command line args",
            "\timport argparse  # to parse options for us and print a nice help message",
            "",
            "\t# get the args passed to blender after \"--\", all of which are ignored by",
            "\t# blender so scripts may receive their own arguments",
            "\targv = sys.argv",
            "",
            "\tif \"--\" not in argv:",
            "\t\targv = []  # as if no args are passed",
            "\telse:",
            "\t\targv = argv[argv.index(\"--\") + 1:]  # get all args after \"--\"",
            "",
            "\t# When --help or no args are given, print this help",
            "\tusage_text = (",
            "\t\t\t\"Run blender in background mode with this script:\"",
            "\t\t\t\"  blender --background --python \" + __file__ + \" -- [options]\"",
            "\t\t\t)",
            "",
            "\tparser = argparse.ArgumentParser(description=usage_text)",
            "",
            "\t# Example utility, add some text and renders or saves it (with options)",
            "\t# Possible types are: string, int, long, choice, float and complex.",
            "\tparser.add_argument(\"-t\", \"--text\", dest=\"text\", type=str, required=True,",
            "\t\t\thelp=\"This text will be used to render an image\")",
            "",
            "\tparser.add_argument(\"-s\", \"--save\", dest=\"save_path\", metavar='FILE',",
            "\t\t\thelp=\"Save the generated file to the specified path\")",
            "\tparser.add_argument(\"-r\", \"--render\", dest=\"render_path\", metavar='FILE',",
            "\t\t\thelp=\"Render an image to the specified path\")",
            "",
            "\targs = parser.parse_args(argv)  # In this example we wont use the args",
            "",
            "\tif not argv:",
            "\t\tparser.print_help()",
            "\t\treturn",
            "",
            "\tif not args.text:",
            "\t\tprint(\"Error: --text=\\\"some string\\\" argument not given, aborting.\")",
            "\t\tparser.print_help()",
            "\t\treturn",
            "",
            "\t# Run the example function",
            "\texample_function(args.text, args.save_path, args.render_path)",
            "",
            "\tprint(\"batch job finished, exiting\")",
            "",
            "",
            "if __name__ == \"__main__\":",
            "\tmain()"
        ],
        "description": "Example of script that shows how you can run blender from the command line (in background mode with no interface) to automate tasks, in this example it creates a text object, camera and light, then renders and/or saves it. This example also shows how you can parse command line options to scripts."
    },
    "template_batch_export":{
        "prefix": "template batch",
        "body": [
            "# exports each selected object into its own file",
            "",
            "import bpy",
            "import os",
            "",
            "# export to blend file location",
            "basedir = os.path.dirname(bpy.data.filepath)",
            "",
            "if not basedir:",
            "\traise Exception(\"Blend file is not saved\")",
            "",
            "scene = bpy.context.scene",
            "",
            "obj_active = scene.objects.active",
            "selection = bpy.context.selected_objects",
            "",
            "bpy.ops.object.select_all(action='DESELECT')",
            "",
            "for obj in selection:",
            "",
            "\tobj.select = True",
            "",
            "\t# some exporters only use the active object",
            "\tscene.objects.active = obj",
            "",
            "\tname = bpy.path.clean_name(obj.name)",
            "\tfn = os.path.join(basedir, name)",
            "",
            "\tbpy.ops.export_scene.fbx(filepath=fn + \".fbx\", use_selection=True)",
            "",
            "\t## Can be used for multiple formats",
            "\t# bpy.ops.export_scene.x3d(filepath=fn + \".x3d\", use_selection=True)",
            "",
            "\tobj.select = False",
            "",
            "\tprint(\"written:\", fn)",
            "",
            "",
            "scene.objects.active = obj_active",
            "",
            "for obj in selection:",
            "\tobj.select = True"
        ],
        "description": "Example of exporting each selected object into its own file"
    },
    "template_bmesh_simple_editmode":{
        "prefix": "template bmesh",
        "body": [
            "# This example assumes we have a mesh object in edit-mode",
            "",
            "import bpy",
            "import bmesh",
            "",
            "# Get the active mesh",
            "obj = bpy.context.edit_object",
            "me = obj.data",
            "",
            "",
            "# Get a BMesh representation",
            "bm = bmesh.from_edit_mesh(me)",
            "",
            "bm.faces.active = None",
            "",
            "# Modify the BMesh, can do anything here...",
            "for v in bm.verts:",
            "\tv.co.x += 1.0",
            "",
            "",
            "# Show the updates in the viewport",
            "# and recalculate n-gon tessellation.",
            "bmesh.update_edit_mesh(me, True)"
        ],
        "description": "Example of to get mesh representation for bmesh from edit-mode and updating it back after bmesh operation."
    },
    "template_bmesh_simple_active_object":{
        "prefix": "template bmesh",
        "body": [
            "# This example assumes we have a mesh object selected",
            "",
            "import bpy",
            "import bmesh",
            "",
            "# Get the active mesh",
            "me = bpy.context.object.data",
            "",
            "",
            "# Get a BMesh representation",
            "bm = bmesh.new()   # create an empty BMesh",
            "bm.from_mesh(me)   # fill it in from a Mesh",
            "",
            "",
            "# Modify the BMesh, can do anything here...",
            "for v in bm.verts:",
            "\tv.co.x += 1.0",
            "",
            "",
            "# Finish up, write the bmesh back to the mesh",
            "bm.to_mesh(me)",
            "bm.free()  # free and prevent further access"
        ],
        "description": "Example of to get mesh representation for bmesh from active object and updating it back after bmesh operation."
    },
    "template_builtin_keyingset":{
        "prefix": "template keyingset",
        "body": [
            "import bpy",
            "",
            "",
            "class BUILTIN_KSI_hello(bpy.types.KeyingSetInfo):",
            "\tbl_label = \"Hello World KeyingSet\"",
            "",
            "\t# poll - test for whether Keying Set can be used at all",
            "\tdef poll(ksi, context):",
            "\t\treturn context.active_object or context.selected_objects",
            "",
            "\t# iterator - go over all relevant data, calling generate()",
            "\tdef iterator(ksi, context, ks):",
            "\t\tfor ob in context.selected_objects:",
            "\t\t\tksi.generate(context, ks, ob)",
            "",
            "\t# generator - populate Keying Set with property paths to use",
            "\tdef generate(ksi, context, ks, data):",
            "\t\tid_block = data.id_data",
            "",
            "\t\tks.paths.add(id_block, \"location\")",
            "",
            "\t\tfor i in range(5):",
            "\t\t\tks.paths.add(id_block, \"layers\", i, group_method='NAMED', group_name=\"5x Hello Layers\")",
            "",
            "\t\tks.paths.add(id_block, \"show_x_ray\", group_method='NONE')",
            "",
            "",
            "def register():",
            "\tbpy.utils.register_class(BUILTIN_KSI_hello)",
            "",
            "",
            "def unregister():",
            "\tbpy.utils.unregister_class(BUILTIN_KSI_hello)",
            "",
            "",
            "if __name__ == '__main__':",
            "\tregister()"
        ],
        "description": "Example of generating Keying Set"
    },
    "template_custom_nodes":{
        "prefix": "template nodes",
        "body": [
            "import bpy",
            "from bpy.types import NodeTree, Node, NodeSocket",
            "",
            "# Implementation of custom nodes from Python",
            "",
            "",
            "# Derived from the NodeTree base type, similar to Menu, Operator, Panel, etc.",
            "class MyCustomTree(NodeTree):",
            "\t# Description string",
            "\t'''A custom node tree type that will show up in the node editor header'''",
            "\t# Optional identifier string. If not explicitly defined, the python class name is used.",
            "\tbl_idname = 'CustomTreeType'",
            "\t# Label for nice name display",
            "\tbl_label = 'Custom Node Tree'",
            "\t# Icon identifier",
            "\tbl_icon = 'NODETREE'",
            "",
            "",
            "# Custom socket type",
            "class MyCustomSocket(NodeSocket):",
            "\t# Description string",
            "\t'''Custom node socket type'''",
            "\t# Optional identifier string. If not explicitly defined, the python class name is used.",
            "\tbl_idname = 'CustomSocketType'",
            "\t# Label for nice name display",
            "\tbl_label = 'Custom Node Socket'",
            "",
            "\t# Enum items list",
            "\tmy_items = [",
            "\t\t(\"DOWN\", \"Down\", \"Where your feet are\"),",
            "\t\t(\"UP\", \"Up\", \"Where your head should be\"),",
            "\t\t(\"LEFT\", \"Left\", \"Not right\"),",
            "\t\t(\"RIGHT\", \"Right\", \"Not left\")",
            "\t]",
            "",
            "\tmyEnumProperty = bpy.props.EnumProperty(name=\"Direction\", description=\"Just an example\", items=my_items, default='UP')",
            "",
            "\t# Optional function for drawing the socket input value",
            "\tdef draw(self, context, layout, node, text):",
            "\t\tif self.is_output or self.is_linked:",
            "\t\t\tlayout.label(text)",
            "\t\telse:",
            "\t\t\tlayout.prop(self, \"myEnumProperty\", text=text)",
            "",
            "\t# Socket color",
            "\tdef draw_color(self, context, node):",
            "\t\treturn (1.0, 0.4, 0.216, 0.5)",
            "",
            "",
            "# Mix-in class for all custom nodes in this tree type.",
            "# Defines a poll function to enable instantiation.",
            "class MyCustomTreeNode:",
            "\t@classmethod",
            "\tdef poll(cls, ntree):",
            "\t\treturn ntree.bl_idname == 'CustomTreeType'",
            "",
            "",
            "# Derived from the Node base type.",
            "class MyCustomNode(Node, MyCustomTreeNode):",
            "\t# === Basics ===",
            "\t# Description string",
            "\t'''A custom node'''",
            "\t# Optional identifier string. If not explicitly defined, the python class name is used.",
            "\tbl_idname = 'CustomNodeType'",
            "\t# Label for nice name display",
            "\tbl_label = 'Custom Node'",
            "\t# Icon identifier",
            "\tbl_icon = 'SOUND'",
            "",
            "\t# === Custom Properties ===",
            "\t# These work just like custom properties in ID data blocks",
            "\t# Extensive information can be found under",
            "\t# http://wiki.blender.org/index.php/Doc:2.6/Manual/Extensions/Python/Properties",
            "\tmyStringProperty = bpy.props.StringProperty()",
            "\tmyFloatProperty = bpy.props.FloatProperty(default=3.1415926)",
            "",
            "\t# === Optional Functions ===",
            "\t# Initialization function, called when a new node is created.",
            "\t# This is the most common place to create the sockets for a node, as shown below.",
            "\t# NOTE: this is not the same as the standard __init__ function in Python, which is",
            "\t#       a purely internal Python method and unknown to the node system!",
            "\tdef init(self, context):",
            "\t\tself.inputs.new('CustomSocketType', \"Hello\")",
            "\t\tself.inputs.new('NodeSocketFloat', \"World\")",
            "\t\tself.inputs.new('NodeSocketVector', \"!\")",
            "",
            "\t\tself.outputs.new('NodeSocketColor', \"How\")",
            "\t\tself.outputs.new('NodeSocketColor', \"are\")",
            "\t\tself.outputs.new('NodeSocketFloat', \"you\")",
            "",
            "\t# Copy function to initialize a copied node from an existing one.",
            "\tdef copy(self, node):",
            "\t\tprint(\"Copying from node \", node)",
            "",
            "\t# Free function to clean up on removal.",
            "\tdef free(self):",
            "\t\tprint(\"Removing node \", self, \", Goodbye!\")",
            "",
            "\t# Additional buttons displayed on the node.",
            "\tdef draw_buttons(self, context, layout):",
            "\t\tlayout.label(\"Node settings\")",
            "\t\tlayout.prop(self, \"myFloatProperty\")",
            "",
            "\t# Detail buttons in the sidebar.",
            "\t# If this function is not defined, the draw_buttons function is used instead",
            "\tdef draw_buttons_ext(self, context, layout):",
            "\t\tlayout.prop(self, \"myFloatProperty\")",
            "\t\t# myStringProperty button will only be visible in the sidebar",
            "\t\tlayout.prop(self, \"myStringProperty\")",
            "",
            "\t# Optional: custom label",
            "\t# Explicit user label overrides this, but here we can define a label dynamically",
            "\tdef draw_label(self):",
            "\t\treturn \"I am a custom node\"",
            "",
            "",
            "### Node Categories ###",
            "# Node categories are a python system for automatically",
            "# extending the Add menu, toolbar panels and search operator.",
            "# For more examples see release/scripts/startup/nodeitems_builtins.py",
            "",
            "import nodeitems_utils",
            "from nodeitems_utils import NodeCategory, NodeItem",
            "",
            "",
            "# our own base class with an appropriate poll function,",
            "# so the categories only show up in our own tree type",
            "class MyNodeCategory(NodeCategory):",
            "\t@classmethod",
            "\tdef poll(cls, context):",
            "\t\treturn context.space_data.tree_type == 'CustomTreeType'",
            "",
            "# all categories in a list",
            "node_categories = [",
            "\t# identifier, label, items list",
            "\tMyNodeCategory(\"SOMENODES\", \"Some Nodes\", items=[",
            "\t\t# our basic node",
            "\t\tNodeItem(\"CustomNodeType\"),",
            "\t\t]),",
            "\tMyNodeCategory(\"OTHERNODES\", \"Other Nodes\", items=[",
            "\t\t# the node item can have additional settings,",
            "\t\t# which are applied to new nodes",
            "\t\t# NB: settings values are stored as string expressions,",
            "\t\t# for this reason they should be converted to strings using repr()",
            "\t\tNodeItem(\"CustomNodeType\", label=\"Node A\", settings={",
            "\t\t\t\"myStringProperty\": repr(\"Lorem ipsum dolor sit amet\"),",
            "\t\t\t\"myFloatProperty\": repr(1.0),",
            "\t\t\t}),",
            "\t\tNodeItem(\"CustomNodeType\", label=\"Node B\", settings={",
            "\t\t\t\"myStringProperty\": repr(\"consectetur adipisicing elit\"),",
            "\t\t\t\"myFloatProperty\": repr(2.0),",
            "\t\t\t}),",
            "\t\t]),",
            "\t]",
            "",
            "",
            "def register():",
            "\tbpy.utils.register_class(MyCustomTree)",
            "\tbpy.utils.register_class(MyCustomSocket)",
            "\tbpy.utils.register_class(MyCustomNode)",
            "",
            "\tnodeitems_utils.register_node_categories(\"CUSTOM_NODES\", node_categories)",
            "",
            "",
            "def unregister():",
            "\tnodeitems_utils.unregister_node_categories(\"CUSTOM_NODES\")",
            "",
            "\tbpy.utils.unregister_class(MyCustomTree)",
            "\tbpy.utils.unregister_class(MyCustomSocket)",
            "\tbpy.utils.unregister_class(MyCustomNode)",
            "",
            "",
            "if __name__ == \"__main__\":",
            "\tregister()"
        ],
        "description": "Example of Implementation of custom nodes from Python"
    },
    "template_driver_functions":{
        "prefix": "template driver",
        "body": [
            "# This script defines functions to be used directly in drivers expressions to",
            "# extend the builtin set of python functions.",
            "#",
            "# This can be executed on manually or set to 'Register' to",
            "# initialize thefunctions on file load.",
            "",
            "",
            "# two sample functions",
            "def invert(f):",
            "\t\"\"\" Simple function call:",
            "",
            "\t         invert(val)",
            "\t\"\"\"",
            "\treturn 1.0 - f",
            "",
            "",
            "uuid_store = {}",
            "",
            "",
            "def slow_value(value, fac, uuid):",
            "\t\"\"\" Delay the value by a factor, use a unique string to allow",
            "\t    use in multiple drivers without conflict:",
            "",
            "\t        slow_value(val, 0.5, \"my_value\")",
            "\t\"\"\"",
            "\tvalue_prev = uuid_store.get(uuid, value)",
            "\tuuid_store[uuid] = value_new = (value_prev * fac) + (value * (1.0 - fac))",
            "\treturn value_new",
            "",
            "",
            "import bpy",
            "",
            "# Add variable defined in this script into the drivers namespace.",
            "bpy.app.driver_namespace[\"invert\"] = invert",
            "bpy.app.driver_namespace[\"slow_value\"] = slow_value"
        ],
        "description": "Example of script defining functions to be used directly in drivers expressions to extend the builtin set of python functions."
    },
    "template_external_script_stub":{
        "prefix": "template script",
        "body": [
            "# This stub runs a python script relative to the currently open",
            "# blend file, useful when editing scripts externally.",
            "",
            "import bpy",
            "import os",
            "",
            "# Use your own script name here:",
            "filename = \"my_script.py\"",
            "",
            "filepath = os.path.join(os.path.dirname(bpy.data.filepath), filename)",
            "global_namespace = {\"__file__\": filepath, \"__name__\": \"__main__\"}",
            "with open(filepath, 'rb') as file:",
            "\texec(compile(file.read(), filepath, 'exec'), global_namespace)"
        ],
        "description": "Example of loading script relative to current blend file. This stub runs a python script relative to the currently open blend file, useful when editing scripts externally."
    },
    "template_gamelogic_module":{
        "prefix": "template gamelogic",
        "body": [
            "# This module can be accessed by a python controller with",
            "# its execution method set to 'Module'",
            "# * Set the module string to \"gamelogic_module.main\" (without quotes)",
            "# * When renaming the script it MUST have a .py extension",
            "# * External text modules are supported as long as they are at",
            "#   the same location as the blendfile or one of its libraries.",
            "",
            "import bge",
            "",
            "# variables defined here will only be set once when the",
            "# module is first imported. Set object specific vars",
            "# inside the function if you intend to use the module",
            "# with multiple objects.",
            "",
            "",
            "def main(cont):",
            "\town = cont.owner",
            "",
            "\tsens = cont.sensors['mySensor']",
            "\tactu = cont.actuators['myActuator']",
            "",
            "\tif sens.positive:",
            "\t\tcont.activate(actu)",
            "\telse:",
            "\t\tcont.deactivate(actu)",
            "",
            "# dont call main(bge.logic.getCurrentController()), the py controller will"
        ],
        "description": "Example of gamelogic module. This module can be accessed by a python controller with its execution method set to 'Module'"
    },
    "template_gamelogic_simple":{
        "prefix": "template gamelogic",
        "body": [
            "import bge",
            "",
            "",
            "def main():",
            "",
            "\tcont = bge.logic.getCurrentController()",
            "\town = cont.owner",
            "",
            "\tsens = cont.sensors['mySensor']",
            "\tactu = cont.actuators['myActuator']",
            "",
            "\tif sens.positive:",
            "\t\tcont.activate(actu)",
            "\telse:",
            "\t\tcont.deactivate(actu)",
            "",
            "main()"
        ],
        "description": "Example of Simple gamelogic python script."
    },
    "template_gamelogic":{
        "prefix": "template gamelogic",
        "body": [
            "# This script must be assigned to a python controller",
            "# where it can access the object that owns it and the sensors/actuators that it connects to.",
            "",
            "import bge",
            "",
            "# support for Vector(), Matrix() types and advanced functions like Matrix.Scale(...) and Matrix.Rotation(...)",
            "# import mathutils",
            "",
            "# for functions like getWindowWidth(), getWindowHeight()",
            "# import Rasterizer",
            "",
            "",
            "def main():",
            "\tcont = bge.logic.getCurrentController()",
            "",
            "\t# The KX_GameObject that owns this controller.",
            "\town = cont.owner",
            "",
            "\t# for scripts that deal with spacial logic",
            "\town_pos = own.worldPosition",
            "",
            "\t# Some example functions, remove to write your own script.",
            "\t# check for a positive sensor, will run on any object without errors.",
            "\tprint(\"Logic info for KX_GameObject\", own.name)",
            "\tinput = False",
            "",
            "\tfor sens in cont.sensors:",
            "\t\t# The sensor can be on another object, we may want to use it",
            "\t\town_sens = sens.owner",
            "\t\tprint(\"    sensor:\", sens.name, end=\" \")",
            "\t\tif sens.positive:",
            "\t\t\tprint(\"(true)\")",
            "\t\t\tinput = True",
            "\t\telse:",
            "\t\t\tprint(\"(false)\")",
            "",
            "\tfor actu in cont.actuators:",
            "\t\t# The actuator can be on another object, we may want to use it",
            "\t\town_actu = actu.owner",
            "\t\tprint(\"    actuator:\", actu.name)",
            "",
            "\t\t# This runs the actuator or turns it off",
            "\t\t# note that actuators will continue to run unless explicitly turned off.",
            "\t\tif input:",
            "\t\t\tcont.activate(actu)",
            "\t\telse:",
            "\t\t\tcont.deactivate(actu)",
            "",
            "\t# Its also good practice to get sensors and actuators by name",
            "\t# rather then index so any changes to their order wont break the script.",
            "",
            "\t# sens_key = cont.sensors[\"key_sensor\"]",
            "\t# actu_motion = cont.actuators[\"motion\"]",
            "",
            "\t# Loop through all other objects in the scene",
            "\tsce = bge.logic.getCurrentScene()",
            "\tprint(\"Scene Objects:\", sce.name)",
            "\tfor ob in sce.objects:",
            "\t\tprint(\"   \", ob.name, ob.worldPosition)",
            "",
            "\t# Example where collision objects are checked for their properties",
            "\t# adding to our objects \"life\" property",
            "\t\"\"\"",
            "\tactu_collide = cont.sensors[\"collision_sens\"]",
            "\tfor ob in actu_collide.hitObjectList:",
            "\t\t# Check to see the object has this property",
            "\t\tif \"life\" in ob:",
            "\t\t\town[\"life\"] += ob[\"life\"]",
            "\t\t\tob[\"life\"] = 0",
            "\tprint(own[\"life\"])",
            "\t\"\"\"",
            "",
            "main()"
        ],
        "description": "Example of gamelogic script this must be assigned to a python controller where it can access the object that owns it and the sensors/actuators that it connects to."
    },
    "template_operator_file_export":{
        "prefix": "template operator",
        "body": [
            "import bpy",
            "",
            "",
            "def write_some_data(context, filepath, use_some_setting):",
            "\tprint(\"running write_some_data...\")",
            "\tf = open(filepath, 'w', encoding='utf-8')",
            "\tf.write(\"Hello World %s\" % use_some_setting)",
            "\tf.close()",
            "",
            "\treturn {'FINISHED'}",
            "",
            "",
            "# ExportHelper is a helper class, defines filename and",
            "# invoke() function which calls the file selector.",
            "from bpy_extras.io_utils import ExportHelper",
            "from bpy.props import StringProperty, BoolProperty, EnumProperty",
            "from bpy.types import Operator",
            "",
            "",
            "class ExportSomeData(Operator, ExportHelper):",
            "\t\"\"\"This appears in the tooltip of the operator and in the generated docs\"\"\"",
            "\tbl_idname = \"export_test.some_data\"  # important since its how bpy.ops.import_test.some_data is constructed",
            "\tbl_label = \"Export Some Data\"",
            "",
            "\t# ExportHelper mixin class uses this",
            "\tfilename_ext = \".txt\"",
            "",
            "\tfilter_glob = StringProperty(",
            "\t\t\tdefault=\"*.txt\",",
            "\t\t\toptions={'HIDDEN'},",
            "\t\t\tmaxlen=255,  # Max internal buffer length, longer would be clamped.",
            "\t\t\t)",
            "",
            "\t# List of operator properties, the attributes will be assigned",
            "\t# to the class instance from the operator settings before calling.",
            "\tuse_setting = BoolProperty(",
            "\t\t\tname=\"Example Boolean\",",
            "\t\t\tdescription=\"Example Tooltip\",",
            "\t\t\tdefault=True,",
            "\t\t\t)",
            "",
            "\ttype = EnumProperty(",
            "\t\t\tname=\"Example Enum\",",
            "\t\t\tdescription=\"Choose between two items\",",
            "\t\t\titems=(('OPT_A', \"First Option\", \"Description one\"),",
            "\t\t\t       ('OPT_B', \"Second Option\", \"Description two\")),",
            "\t\t\tdefault='OPT_A',",
            "\t\t\t)",
            "",
            "\tdef execute(self, context):",
            "\t\treturn write_some_data(context, self.filepath, self.use_setting)",
            "",
            "",
            "# Only needed if you want to add into a dynamic menu",
            "def menu_func_export(self, context):",
            "\tself.layout.operator(ExportSomeData.bl_idname, text=\"Text Export Operator\")",
            "",
            "",
            "def register():",
            "\tbpy.utils.register_class(ExportSomeData)",
            "\tbpy.types.INFO_MT_file_export.append(menu_func_export)",
            "",
            "",
            "def unregister():",
            "\tbpy.utils.unregister_class(ExportSomeData)",
            "\tbpy.types.INFO_MT_file_export.remove(menu_func_export)",
            "",
            "",
            "if __name__ == \"__main__\":",
            "\tregister()",
            "",
            "\t# test call",
            "\tbpy.ops.export_test.some_data('INVOKE_DEFAULT')"
        ],
        "description": "Example of Template for file export operator, operator exports data from blender to .txt file"
    },
    "template_operator_file_import":{
        "prefix": "template operator",
        "body": [
            "import bpy",
            "",
            "",
            "def read_some_data(context, filepath, use_some_setting):",
            "\tprint(\"running read_some_data...\")",
            "\tf = open(filepath, 'r', encoding='utf-8')",
            "\tdata = f.read()",
            "\tf.close()",
            "",
            "\t# would normally load the data here",
            "\tprint(data)",
            "",
            "\treturn {'FINISHED'}",
            "",
            "",
            "# ImportHelper is a helper class, defines filename and",
            "# invoke() function which calls the file selector.",
            "from bpy_extras.io_utils import ImportHelper",
            "from bpy.props import StringProperty, BoolProperty, EnumProperty",
            "from bpy.types import Operator",
            "",
            "",
            "class ImportSomeData(Operator, ImportHelper):",
            "\t\"\"\"This appears in the tooltip of the operator and in the generated docs\"\"\"",
            "\tbl_idname = \"import_test.some_data\"  # important since its how bpy.ops.import_test.some_data is constructed",
            "\tbl_label = \"Import Some Data\"",
            "",
            "\t# ImportHelper mixin class uses this",
            "\tfilename_ext = \".txt\"",
            "",
            "\tfilter_glob = StringProperty(",
            "\t\t\tdefault=\"*.txt\",",
            "\t\t\toptions={'HIDDEN'},",
            "\t\t\tmaxlen=255,  # Max internal buffer length, longer would be clamped.",
            "\t\t\t)",
            "",
            "\t# List of operator properties, the attributes will be assigned",
            "\t# to the class instance from the operator settings before calling.",
            "\tuse_setting = BoolProperty(",
            "\t\t\tname=\"Example Boolean\",",
            "\t\t\tdescription=\"Example Tooltip\",",
            "\t\t\tdefault=True,",
            "\t\t\t)",
            "",
            "\ttype = EnumProperty(",
            "\t\t\tname=\"Example Enum\",",
            "\t\t\tdescription=\"Choose between two items\",",
            "\t\t\titems=(('OPT_A', \"First Option\", \"Description one\"),",
            "\t\t\t       ('OPT_B', \"Second Option\", \"Description two\")),",
            "\t\t\tdefault='OPT_A',",
            "\t\t\t)",
            "",
            "\tdef execute(self, context):",
            "\t\treturn read_some_data(context, self.filepath, self.use_setting)",
            "",
            "",
            "# Only needed if you want to add into a dynamic menu",
            "def menu_func_import(self, context):",
            "\tself.layout.operator(ImportSomeData.bl_idname, text=\"Text Import Operator\")",
            "",
            "",
            "def register():",
            "\tbpy.utils.register_class(ImportSomeData)",
            "\tbpy.types.INFO_MT_file_import.append(menu_func_import)",
            "",
            "",
            "def unregister():",
            "\tbpy.utils.unregister_class(ImportSomeData)",
            "\tbpy.types.INFO_MT_file_import.remove(menu_func_import)",
            "",
            "",
            "if __name__ == \"__main__\":",
            "\tregister()",
            "",
            "\t# test call",
            "\tbpy.ops.import_test.some_data('INVOKE_DEFAULT')"
        ],
        "description": "Example of Template for file import operator, operator imports data from .txt to blender data"
    },
    "template_opertator_mesh_add":{
        "prefix": "template operator",
        "body": [
            "import bpy",
            "import bmesh",
            "",
            "",
            "def add_box(width, height, depth):",
            "\t\"\"\"",
            "\tThis function takes inputs and returns vertex and face arrays.",
            "\tno actual mesh data creation is done here.",
            "\t\"\"\"",
            "",
            "\tverts = [(+1.0, +1.0, -1.0),",
            "\t         (+1.0, -1.0, -1.0),",
            "\t         (-1.0, -1.0, -1.0),",
            "\t         (-1.0, +1.0, -1.0),",
            "\t         (+1.0, +1.0, +1.0),",
            "\t         (+1.0, -1.0, +1.0),",
            "\t         (-1.0, -1.0, +1.0),",
            "\t         (-1.0, +1.0, +1.0),",
            "\t         ]",
            "",
            "\tfaces = [(0, 1, 2, 3),",
            "\t         (4, 7, 6, 5),",
            "\t         (0, 4, 5, 1),",
            "\t         (1, 5, 6, 2),",
            "\t         (2, 6, 7, 3),",
            "\t         (4, 0, 3, 7),",
            "\t         ]",
            "",
            "\t# apply size",
            "\tfor i, v in enumerate(verts):",
            "\t\tverts[i] = v[0] * width, v[1] * depth, v[2] * height",
            "",
            "\treturn verts, faces",
            "",
            "",
            "from bpy.props import (",
            "\t\tBoolProperty,",
            "\t\tBoolVectorProperty,",
            "\t\tFloatProperty,",
            "\t\tFloatVectorProperty,",
            "\t\t)",
            "",
            "",
            "class AddBox(bpy.types.Operator):",
            "\t\"\"\"Add a simple box mesh\"\"\"",
            "\tbl_idname = \"mesh.primitive_box_add\"",
            "\tbl_label = \"Add Box\"",
            "\tbl_options = {'REGISTER', 'UNDO'}",
            "",
            "\twidth = FloatProperty(",
            "\t\t\tname=\"Width\",",
            "\t\t\tdescription=\"Box Width\",",
            "\t\t\tmin=0.01, max=100.0,",
            "\t\t\tdefault=1.0,",
            "\t\t\t)",
            "\theight = FloatProperty(",
            "\t\t\tname=\"Height\",",
            "\t\t\tdescription=\"Box Height\",",
            "\t\t\tmin=0.01, max=100.0,",
            "\t\t\tdefault=1.0,",
            "\t\t\t)",
            "\tdepth = FloatProperty(",
            "\t\t\tname=\"Depth\",",
            "\t\t\tdescription=\"Box Depth\",",
            "\t\t\tmin=0.01, max=100.0,",
            "\t\t\tdefault=1.0,",
            "\t\t\t)",
            "\tlayers = BoolVectorProperty(",
            "\t\t\tname=\"Layers\",",
            "\t\t\tdescription=\"Object Layers\",",
            "\t\t\tsize=20,",
            "\t\t\toptions={'HIDDEN', 'SKIP_SAVE'},",
            "\t\t\t)",
            "",
            "\t# generic transform props",
            "\tview_align = BoolProperty(",
            "\t\t\tname=\"Align to View\",",
            "\t\t\tdefault=False,",
            "\t\t\t)",
            "\tlocation = FloatVectorProperty(",
            "\t\t\tname=\"Location\",",
            "\t\t\tsubtype='TRANSLATION',",
            "\t\t\t)",
            "\trotation = FloatVectorProperty(",
            "\t\t\tname=\"Rotation\",",
            "\t\t\tsubtype='EULER',",
            "\t\t\t)",
            "",
            "\tdef execute(self, context):",
            "",
            "\t\tverts_loc, faces = add_box(self.width,",
            "\t\t                           self.height,",
            "\t\t                           self.depth,",
            "\t\t                           )",
            "",
            "\t\tmesh = bpy.data.meshes.new(\"Box\")",
            "",
            "\t\tbm = bmesh.new()",
            "",
            "\t\tfor v_co in verts_loc:",
            "\t\t\tbm.verts.new(v_co)",
            "",
            "\t\tbm.verts.ensure_lookup_table()",
            "\t\tfor f_idx in faces:",
            "\t\t\tbm.faces.new([bm.verts[i] for i in f_idx])",
            "",
            "\t\tbm.to_mesh(mesh)",
            "\t\tmesh.update()",
            "",
            "\t\t# add the mesh as an object into the scene with this utility module",
            "\t\tfrom bpy_extras import object_utils",
            "\t\tobject_utils.object_data_add(context, mesh, operator=self)",
            "",
            "\t\treturn {'FINISHED'}",
            "",
            "",
            "def menu_func(self, context):",
            "\tself.layout.operator(AddBox.bl_idname, icon='MESH_CUBE')",
            "",
            "",
            "def register():",
            "\tbpy.utils.register_class(AddBox)",
            "\tbpy.types.INFO_MT_mesh_add.append(menu_func)",
            "",
            "",
            "def unregister():",
            "\tbpy.utils.unregister_class(AddBox)",
            "\tbpy.types.INFO_MT_mesh_add.remove(menu_func)",
            "",
            "if __name__ == \"__main__\":",
            "\tregister()",
            "",
            "\t# test call",
            "\tbpy.ops.mesh.primitive_box_add()"
        ],
        "description": "Example of operator involving bmesh for creating and adding object to scene"
    },
    "template_operator_mesh_uv":{
        "prefix": "template operator",
        "body": [
            "import bpy",
            "import bmesh",
            "",
            "",
            "def main(context):",
            "\tobj = context.active_object",
            "\tme = obj.data",
            "\tbm = bmesh.from_edit_mesh(me)",
            "",
            "\tuv_layer = bm.loops.layers.uv.verify()",
            "\tbm.faces.layers.tex.verify()  # currently blender needs both layers.",
            "",
            "\t# adjust UVs",
            "\tfor f in bm.faces:",
            "\t\tfor l in f.loops:",
            "\t\t\tluv = l[uv_layer]",
            "\t\t\tif luv.select:",
            "\t\t\t\t# apply the location of the vertex as a UV",
            "\t\t\t\tluv.uv = l.vert.co.xy",
            "",
            "\tbmesh.update_edit_mesh(me)",
            "",
            "",
            "class UvOperator(bpy.types.Operator):",
            "\t\"\"\"UV Operator description\"\"\"",
            "\tbl_idname = \"uv.simple_operator\"",
            "\tbl_label = \"Simple UV Operator\"",
            "",
            "\t@classmethod",
            "\tdef poll(cls, context):",
            "\t\treturn (context.mode == 'EDIT_MESH')",
            "",
            "\tdef execute(self, context):",
            "\t\tmain(context)",
            "\t\treturn {'FINISHED'}",
            "",
            "",
            "def register():",
            "\tbpy.utils.register_class(UvOperator)",
            "",
            "",
            "def unregister():",
            "\tbpy.utils.unregister_class(UvOperator)",
            "",
            "",
            "if __name__ == \"__main__\":",
            "\tregister()",
            "",
            "\t# test call",
            "\tbpy.ops.uv.simple_operator()"
        ],
        "description": "Example of Operator template for editing mesh UV's with bmesh"
    },
    "template_operator_simple":{
        "prefix": "template operator",
        "body": [
            "import bpy",
            "",
            "",
            "def main(context):",
            "\tfor ob in context.scene.objects:",
            "\t\tprint(ob)",
            "",
            "",
            "class SimpleOperator(bpy.types.Operator):",
            "\t\"\"\"Tooltip\"\"\"",
            "\tbl_idname = \"object.simple_operator\"",
            "\tbl_label = \"Simple Object Operator\"",
            "",
            "\t@classmethod",
            "\tdef poll(cls, context):",
            "\t\treturn context.active_object is not None",
            "",
            "\tdef execute(self, context):",
            "\t\tmain(context)",
            "\t\treturn {'FINISHED'}",
            "",
            "",
            "def register():",
            "\tbpy.utils.register_class(SimpleOperator)",
            "",
            "",
            "def unregister():",
            "\tbpy.utils.unregister_class(SimpleOperator)",
            "",
            "",
            "if __name__ == \"__main__\":",
            "\tregister()",
            "",
            "\t# test call",
            "\tbpy.ops.object.simple_operator()"
        ],
        "description": "Example of Blender modal operator function with imports, main function, register, unregister and testcall"
    },
    "template_ui_list_w_panel":{
        "prefix": "template ui list",
        "body": [
            "import bpy",
            "",
            "",
            "class MATERIAL_UL_matslots_example(bpy.types.UIList):",
            "\t# The draw_item function is called for each item of the collection that is visible in the list.",
            "\t#   data is the RNA object containing the collection,",
            "\t#   item is the current drawn item of the collection,",
            "\t#   icon is the \"computed\" icon for the item (as an integer, because some objects like materials or textures",
            "\t#   have custom icons ID, which are not available as enum items).",
            "\t#   active_data is the RNA object containing the active property for the collection (i.e. integer pointing to the",
            "\t#   active item of the collection).",
            "\t#   active_propname is the name of the active property (use 'getattr(active_data, active_propname)').",
            "\t#   index is index of the current item in the collection.",
            "\t#   flt_flag is the result of the filtering process for this item.",
            "\t#   Note: as index and flt_flag are optional arguments, you do not have to use/declare them here if you don't",
            "\t#         need them.",
            "\tdef draw_item(self, context, layout, data, item, icon, active_data, active_propname):",
            "\t\tob = data",
            "\t\tslot = item",
            "\t\tma = slot.material",
            "\t\t# draw_item must handle the three layout types... Usually 'DEFAULT' and 'COMPACT' can share the same code.",
            "\t\tif self.layout_type in {'DEFAULT', 'COMPACT'}:",
            "\t\t\t# You should always start your row layout by a label (icon + text), or a non-embossed text field,",
            "\t\t\t# this will also make the row easily selectable in the list! The later also enables ctrl-click rename.",
            "\t\t\t# We use icon_value of label, as our given icon is an integer value, not an enum ID.",
            "\t\t\t# Note \"data\" names should never be translated!",
            "\t\t\tif ma:",
            "\t\t\t\tlayout.prop(ma, \"name\", text=\"\", emboss=False, icon_value=icon)",
            "\t\t\telse:",
            "\t\t\t\tlayout.label(text=\"\", translate=False, icon_value=icon)",
            "\t\t\t# And now we can add other UI stuff...",
            "\t\t\t# Here, we add nodes info if this material uses (old!) shading nodes.",
            "\t\t\tif ma and not context.scene.render.use_shading_nodes:",
            "\t\t\t\tmanode = ma.active_node_material",
            "\t\t\t\tif manode:",
            "\t\t\t\t\t# The static method UILayout.icon returns the integer value of the icon ID \"computed\" for the given",
            "\t\t\t\t\t# RNA object.",
            "\t\t\t\t\tlayout.label(text=\"Node %s\" % manode.name, translate=False, icon_value=layout.icon(manode))",
            "\t\t\t\telif ma.use_nodes:",
            "\t\t\t\t\tlayout.label(text=\"Node <none>\", translate=False)",
            "\t\t\t\telse:",
            "\t\t\t\t\tlayout.label(text=\"\")",
            "\t\t# 'GRID' layout type should be as compact as possible (typically a single icon!).",
            "\t\telif self.layout_type in {'GRID'}:",
            "\t\t\tlayout.alignment = 'CENTER'",
            "\t\t\tlayout.label(text=\"\", icon_value=icon)",
            "",
            "",
            "# And now we can use this list everywhere in Blender. Here is a small example panel.",
            "class UIListPanelExample(bpy.types.Panel):",
            "\t\"\"\"Creates a Panel in the Object properties window\"\"\"",
            "\tbl_label = \"UIList Panel\"",
            "\tbl_idname = \"OBJECT_PT_ui_list_example\"",
            "\tbl_space_type = 'PROPERTIES'",
            "\tbl_region_type = 'WINDOW'",
            "\tbl_context = \"object\"",
            "",
            "\tdef draw(self, context):",
            "\t\tlayout = self.layout",
            "",
            "\t\tobj = context.object",
            "",
            "\t\t# template_list now takes two new args.",
            "\t\t# The first one is the identifier of the registered UIList to use (if you want only the default list,",
            "\t\t# with no custom draw code, use \"UI_UL_list\").",
            "\t\tlayout.template_list(\"MATERIAL_UL_matslots_example\", \"\", obj, \"material_slots\", obj, \"active_material_index\")",
            "",
            "\t\t# The second one can usually be left as an empty string. It's an additional ID used to distinguish lists in case you",
            "\t\t# use the same list several times in a given area.",
            "\t\tlayout.template_list(\"MATERIAL_UL_matslots_example\", \"compact\", obj, \"material_slots\",",
            "\t\t                     obj, \"active_material_index\", type='COMPACT')",
            "",
            "",
            "def register():",
            "\tbpy.utils.register_class(MATERIAL_UL_matslots_example)",
            "\tbpy.utils.register_class(UIListPanelExample)",
            "",
            "",
            "def unregister():",
            "\tbpy.utils.unregister_class(MATERIAL_UL_matslots_example)",
            "\tbpy.utils.unregister_class(UIListPanelExample)",
            "",
            "",
            "if __name__ == \"__main__\":",
            "\tregister()"
        ],
        "description": "Example of ui list template with adding it to blender with example panel"
    },
    "template_ui_list":{
        "prefix": "template ui list",
        "body": [
            "import bpy",
            "",
            "",
            "class MESH_UL_mylist(bpy.types.UIList):",
            "\t# Constants (flags)",
            "\t# Be careful not to shadow FILTER_ITEM (i.e. UIList().bitflag_filter_item)!",
            "\t# E.g. VGROUP_EMPTY = 1 << 0",
            "",
            "\t# Custom properties, saved with .blend file. E.g.",
            "\t# use_filter_empty = bpy.props.BoolProperty(name=\"Filter Empty\", default=False, options=set(),",
            "\t#                                           description=\"Whether to filter empty vertex groups\")",
            "",
            "\t# Called for each drawn item.",
            "\tdef draw_item(self, context, layout, data, item, icon, active_data, active_propname, index, flt_flag):",
            "\t\t# 'DEFAULT' and 'COMPACT' layout types should usually use the same draw code.",
            "\t\tif self.layout_type in {'DEFAULT', 'COMPACT'}:",
            "\t\t\tpass",
            "\t\t# 'GRID' layout type should be as compact as possible (typically a single icon!).",
            "\t\telif self.layout_type in {'GRID'}:",
            "\t\t\tpass",
            "",
            "\t# Called once to draw filtering/reordering options.",
            "\tdef draw_filter(self, context, layout):",
            "\t\t# Nothing much to say here, it's usual UI code...",
            "\t\tpass",
            "",
            "\t# Called once to filter/reorder items.",
            "\tdef filter_items(self, context, data, propname):",
            "\t\t# This function gets the collection property (as the usual tuple (data, propname)), and must return two lists:",
            "\t\t# * The first one is for filtering, it must contain 32bit integers were self.bitflag_filter_item marks the",
            "\t\t#   matching item as filtered (i.e. to be shown), and 31 other bits are free for custom needs. Here we use the",
            "\t\t#   first one to mark VGROUP_EMPTY.",
            "\t\t# * The second one is for reordering, it must return a list containing the new indices of the items (which",
            "\t\t#   gives us a mapping org_idx -> new_idx).",
            "\t\t# Please note that the default UI_UL_list defines helper functions for common tasks (see its doc for more info).",
            "\t\t# If you do not make filtering and/or ordering, return empty list(s) (this will be more efficient than",
            "\t\t# returning full lists doing nothing!).",
            "",
            "\t\t# Default return values.",
            "\t\tflt_flags = []",
            "\t\tflt_neworder = []",
            "",
            "\t\t# Do filtering/reordering here...",
            "",
            "\t\treturn flt_flags, flt_neworder"
        ],
        "description": "Example of simple ui list class with some filtering and bpy import"
    },
    "template_ui_menu_simple":{
        "prefix": "template ui menu",
        "body": [
            "import bpy",
            "",
            "",
            "class SimpleCustomMenu(bpy.types.Menu):",
            "\tbl_label = \"Simple Custom Menu\"",
            "\tbl_idname = \"OBJECT_MT_simple_custom_menu\"",
            "",
            "\tdef draw(self, context):",
            "\t\tlayout = self.layout",
            "",
            "\t\tlayout.operator(\"wm.open_mainfile\")",
            "\t\tlayout.operator(\"wm.save_as_mainfile\")",
            "",
            "",
            "def register():",
            "\tbpy.utils.register_class(SimpleCustomMenu)",
            "",
            "",
            "def unregister():",
            "\tbpy.utils.unregister_class(SimpleCustomMenu)",
            "",
            "if __name__ == \"__main__\":",
            "\tregister()",
            "",
            "\t# The menu can also be called from scripts",
            "\tbpy.ops.wm.call_menu(name=SimpleCustomMenu.bl_idname)"
        ],
        "description": "Example of ui menu"
    },
    "template_ui_panel_simple":{
        "prefix": "template ui simple panel",
        "body": [
            "import bpy",
            "",
            "",
            "class HelloWorldPanel(bpy.types.Panel):",
            "\t\"\"\"Creates a Panel in the Object properties window\"\"\"",
            "\tbl_label = \"Hello World Panel\"",
            "\tbl_idname = \"OBJECT_PT_hello\"",
            "\tbl_space_type = 'PROPERTIES'",
            "\tbl_region_type = 'WINDOW'",
            "\tbl_context = \"object\"",
            "",
            "\tdef draw(self, context):",
            "\t\tlayout = self.layout",
            "",
            "\t\tobj = context.object",
            "",
            "\t\trow = layout.row()",
            "\t\trow.label(text=\"Hello world!\", icon='WORLD_DATA')",
            "",
            "\t\trow = layout.row()",
            "\t\trow.label(text=\"Active object is: \" + obj.name)",
            "\t\trow = layout.row()",
            "\t\trow.prop(obj, \"name\")",
            "",
            "\t\trow = layout.row()",
            "\t\trow.operator(\"mesh.primitive_cube_add\")",
            "",
            "",
            "def register():",
            "\tbpy.utils.register_class(HelloWorldPanel)",
            "",
            "",
            "def unregister():",
            "\tbpy.utils.unregister_class(HelloWorldPanel)",
            "",
            "",
            "if __name__ == \"__main__\":",
            "\tregister()"
        ],
        "description": "Example of ui panel class with import and register"
    },
    "template_ui_panel":{
        "prefix": "template ui panel",
        "body": [
            "import bpy",
            "",
            "",
            "class LayoutDemoPanel(bpy.types.Panel):",
            "\t\"\"\"Creates a Panel in the scene context of the properties editor\"\"\"",
            "\tbl_label = \"Layout Demo\"",
            "\tbl_idname = \"SCENE_PT_layout\"",
            "\tbl_space_type = 'PROPERTIES'",
            "\tbl_region_type = 'WINDOW'",
            "\tbl_context = \"scene\"",
            "",
            "\tdef draw(self, context):",
            "\t\tlayout = self.layout",
            "",
            "\t\tscene = context.scene",
            "",
            "\t\t# Create a simple row.",
            "\t\tlayout.label(text=\" Simple Row:\")",
            "",
            "\t\trow = layout.row()",
            "\t\trow.prop(scene, \"frame_start\")",
            "\t\trow.prop(scene, \"frame_end\")",
            "",
            "\t\t# Create an row where the buttons are aligned to each other.",
            "\t\tlayout.label(text=\" Aligned Row:\")",
            "",
            "\t\trow = layout.row(align=True)",
            "\t\trow.prop(scene, \"frame_start\")",
            "\t\trow.prop(scene, \"frame_end\")",
            "",
            "\t\t# Create two columns, by using a split layout.",
            "\t\tsplit = layout.split()",
            "",
            "\t\t# First column",
            "\t\tcol = split.column()",
            "\t\tcol.label(text=\"Column One:\")",
            "\t\tcol.prop(scene, \"frame_end\")",
            "\t\tcol.prop(scene, \"frame_start\")",
            "",
            "\t\t# Second column, aligned",
            "\t\tcol = split.column(align=True)",
            "\t\tcol.label(text=\"Column Two:\")",
            "\t\tcol.prop(scene, \"frame_start\")",
            "\t\tcol.prop(scene, \"frame_end\")",
            "",
            "\t\t# Big render button",
            "\t\tlayout.label(text=\"Big Button:\")",
            "\t\trow = layout.row()",
            "\t\trow.scale_y = 3.0",
            "\t\trow.operator(\"render.render\")",
            "",
            "\t\t# Different sizes in a row",
            "\t\tlayout.label(text=\"Different button sizes:\")",
            "\t\trow = layout.row(align=True)",
            "\t\trow.operator(\"render.render\")",
            "",
            "\t\tsub = row.row()",
            "\t\tsub.scale_x = 2.0",
            "\t\tsub.operator(\"render.render\")",
            "",
            "\t\trow.operator(\"render.render\")",
            "",
            "",
            "def register():",
            "\tbpy.utils.register_class(LayoutDemoPanel)",
            "",
            "",
            "def unregister():",
            "\tbpy.utils.unregister_class(LayoutDemoPanel)",
            "",
            "",
            "if __name__ == \"__main__\":",
            "\tregister()"
        ],
        "description": "Example of ui panel class ui panel is created with examples of columns, buttons, rows, properties, with import and register, "
    },
    "template_ui_pie_menu":{
        "prefix": "template ui pie menu",
        "body": [
            "import bpy",
            "from bpy.types import Menu",
            "",
            "# spawn an edit mode selection pie (run while object is in edit mode to get a valid output)",
            "",
            "",
            "class VIEW3D_PIE_template(Menu):",
            "\t# label is displayed at the center of the pie menu.",
            "\tbl_label = \"Select Mode\"",
            "",
            "\tdef draw(self, context):",
            "\t\tlayout = self.layout",
            "",
            "\t\tpie = layout.menu_pie()",
            "\t\t# operator_enum will just spread all available options",
            "\t\t# for the type enum of the operator on the pie",
            "\t\tpie.operator_enum(\"mesh.select_mode\", \"type\")",
            "",
            "",
            "def register():",
            "\tbpy.utils.register_class(VIEW3D_PIE_template)",
            "",
            "",
            "def unregister():",
            "\tbpy.utils.unregister_class(VIEW3D_PIE_template)",
            "",
            "",
            "if __name__ == \"__main__\":",
            "\tregister()",
            "",
            "\tbpy.ops.wm.call_menu_pie(name=\"VIEW3D_PIE_template\")"
        ],
        "description": "Example of 3d viewport pie menu"
    },
    "template_dynamic_enum":{
        "prefix": "template dynamic enum",
        "body": [
            "# This sample script demonstrates a dynamic EnumProperty with custom icons.",
            "# The EnumProperty is populated dynamically with thumbnails of the contents of",
            "# a chosen directory in 'enum_previews_from_directory_items'.",
            "# Then, the same enum is displayed with different interfaces. Note that the",
            "# generated icon previews do not have Blender IDs, which means that they can",
            "# not be used with UILayout templates that require IDs,",
            "# such as template_list and template_ID_preview.",
            "#",
            "# Other use cases:",
            "# - make a fixed list of enum_items instead of calculating them in a function",
            "# - generate isolated thumbnails to use as custom icons in buttons",
            "#   and menu items",
            "#",
            "# For custom icons, see the template \"ui_previews_custom_icon.py\".",
            "#",
            "# For distributable scripts, it is recommended to place the icons inside the",
            "# script directory and access it relative to the py script file for portability:",
            "#",
            "#\tos.path.join(os.path.dirname(__file__), \"images\")",
            "",
            "",
            "import os",
            "import bpy",
            "",
            "",
            "def enum_previews_from_directory_items(self, context):",
            "\t\"\"\"EnumProperty callback\"\"\"",
            "\tenum_items = []",
            "",
            "\tif context is None:",
            "\t\treturn enum_items",
            "",
            "\twm = context.window_manager",
            "\tdirectory = wm.my_previews_dir",
            "",
            "\t# Get the preview collection (defined in register func).",
            "\tpcoll = preview_collections[\"main\"]",
            "",
            "\tif directory == pcoll.my_previews_dir:",
            "\t\treturn pcoll.my_previews",
            "",
            "\tprint(\"Scanning directory: %s\" % directory)",
            "",
            "\tif directory and os.path.exists(directory):",
            "\t\t# Scan the directory for png files",
            "\t\timage_paths = []",
            "\t\tfor fn in os.listdir(directory):",
            "\t\t\tif fn.lower().endswith(\".png\"):",
            "\t\t\t\timage_paths.append(fn)",
            "",
            "\t\tfor i, name in enumerate(image_paths):",
            "\t\t\t# generates a thumbnail preview for a file.",
            "\t\t\tfilepath = os.path.join(directory, name)",
            "\t\t\tthumb = pcoll.load(filepath, filepath, 'IMAGE')",
            "\t\t\tenum_items.append((name, name, \"\", thumb.icon_id, i))",
            "",
            "\tpcoll.my_previews = enum_items",
            "\tpcoll.my_previews_dir = directory",
            "\treturn pcoll.my_previews",
            "",
            "",
            "class PreviewsExamplePanel(bpy.types.Panel):",
            "\t\"\"\"Creates a Panel in the Object properties window\"\"\"",
            "\tbl_label = \"Previews Example Panel\"",
            "\tbl_idname = \"OBJECT_PT_previews\"",
            "\tbl_space_type = 'PROPERTIES'",
            "\tbl_region_type = 'WINDOW'",
            "\tbl_context = \"object\"",
            "",
            "\tdef draw(self, context):",
            "\t\tlayout = self.layout",
            "\t\twm = context.window_manager",
            "",
            "\t\trow = layout.row()",
            "\t\trow.prop(wm, \"my_previews_dir\")",
            "",
            "\t\trow = layout.row()",
            "\t\trow.template_icon_view(wm, \"my_previews\")",
            "",
            "\t\trow = layout.row()",
            "\t\trow.prop(wm, \"my_previews\")",
            "",
            "",
            "# We can store multiple preview collections here,",
            "# however in this example we only store \"main\"",
            "preview_collections = {}",
            "",
            "",
            "def register():",
            "\tfrom bpy.types import WindowManager",
            "\tfrom bpy.props import (",
            "\t\t\tStringProperty,",
            "\t\t\tEnumProperty,",
            "\t\t\t)",
            "",
            "\tWindowManager.my_previews_dir = StringProperty(",
            "\t\t\tname=\"Folder Path\",",
            "\t\t\tsubtype='DIR_PATH',",
            "\t\t\tdefault=\"\"",
            "\t\t\t)",
            "",
            "\tWindowManager.my_previews = EnumProperty(",
            "\t\t\titems=enum_previews_from_directory_items,",
            "\t\t\t)",
            "",
            "\t# Note that preview collections returned by bpy.utils.previews",
            "\t# are regular Python objects - you can use them to store custom data.",
            "\t#",
            "\t# This is especially useful here, since:",
            "\t# - It avoids us regenerating the whole enum over and over.",
            "\t# - It can store enum_items' strings",
            "\t#   (remember you have to keep those strings somewhere in py,",
            "\t#   else they get freed and Blender references invalid memory!).",
            "\timport bpy.utils.previews",
            "\tpcoll = bpy.utils.previews.new()",
            "\tpcoll.my_previews_dir = \"\"",
            "\tpcoll.my_previews = ()",
            "",
            "\tpreview_collections[\"main\"] = pcoll",
            "",
            "\tbpy.utils.register_class(PreviewsExamplePanel)",
            "",
            "",
            "def unregister():",
            "\tfrom bpy.types import WindowManager",
            "",
            "\tdel WindowManager.my_previews",
            "",
            "\tfor pcoll in preview_collections.values():",
            "\t\tbpy.utils.previews.remove(pcoll)",
            "\tpreview_collections.clear()",
            "",
            "\tbpy.utils.unregister_class(PreviewsExamplePanel)",
            "",
            "",
            "if __name__ == \"__main__\":",
            "\tregister()"
        ],
        "description": "This example script demonstrates a dynamic EnumProperty with custom icons."
    },
    "template_ui_previews_custom_icon":{
        "prefix": "template ui previews",
        "body": [
            "# This sample script demonstrates how to place a custom icon on a button or",
            "# menu entry.",
            "#",
            "# IMPORTANT NOTE: if you run this sample, there will be no icon in the button",
            "# You need to replace the image path with a real existing one.",
            "# For distributable scripts, it is recommended to place the icons inside the",
            "# addon folder and access it relative to the py script file for portability",
            "#",
            "#",
            "# Other use cases for UI-previews:",
            "# - provide a fixed list of previews to select from",
            "# - provide a dynamic list of preview (eg. calculated from reading a directory)",
            "#",
            "# For the above use cases, see the template 'ui_previews_dynamic_enum.py\"",
            "",
            "",
            "import os",
            "import bpy",
            "",
            "",
            "class PreviewsExamplePanel(bpy.types.Panel):",
            "\t\"\"\"Creates a Panel in the Object properties window\"\"\"",
            "\tbl_label = \"Previews Example Panel\"",
            "\tbl_idname = \"OBJECT_PT_previews\"",
            "\tbl_space_type = 'PROPERTIES'",
            "\tbl_region_type = 'WINDOW'",
            "\tbl_context = \"object\"",
            "",
            "\tdef draw(self, context):",
            "\t\tlayout = self.layout",
            "\t\tpcoll = preview_collections[\"main\"]",
            "",
            "\t\trow = layout.row()",
            "\t\tmy_icon = pcoll[\"my_icon\"]",
            "\t\trow.operator(\"render.render\", icon_value=my_icon.icon_id)",
            "",
            "\t\t# my_icon.icon_id can be used in any UI function that accepts",
            "\t\t# icon_value # try also setting text=\"\"",
            "\t\t# to get an icon only operator button",
            "",
            "",
            "# We can store multiple preview collections here,",
            "# however in this example we only store \"main\"",
            "preview_collections = {}",
            "",
            "",
            "def register():",
            "",
            "\t# Note that preview collections returned by bpy.utils.previews",
            "\t# are regular py objects - you can use them to store custom data.",
            "\timport bpy.utils.previews",
            "\tpcoll = bpy.utils.previews.new()",
            "",
            "\t# path to the folder where the icon is",
            "\t# the path is calculated relative to this py file inside the addon folder",
            "\tmy_icons_dir = os.path.join(os.path.dirname(__file__), \"icons\")",
            "",
            "\t# load a preview thumbnail of a file and store in the previews collection",
            "\tpcoll.load(\"my_icon\", os.path.join(my_icons_dir, \"icon-image.png\"), 'IMAGE')",
            "",
            "\tpreview_collections[\"main\"] = pcoll",
            "",
            "\tbpy.utils.register_class(PreviewsExamplePanel)",
            "",
            "",
            "def unregister():",
            "",
            "\tfor pcoll in preview_collections.values():",
            "\t\tbpy.utils.previews.remove(pcoll)",
            "\tpreview_collections.clear()",
            "",
            "\tbpy.utils.unregister_class(PreviewsExamplePanel)",
            "",
            "",
            "if __name__ == \"__main__\":",
            "\tregister()"
        ],
        "description": "This example script demonstrates how to place a custom icon on a button menu entry."
    }

}